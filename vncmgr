#!/bin/bash
#
#   This script helps users create and manage their
#   VNC sessions on the Casper cluster.
#
#   Author:         Brian Vanderwende
#   Last Revised:   09:43, 23 Mar 2020
#

# Make sure environment is configured to run VNC jobs
. /etc/profile >& /dev/null
my_dir="$( cd "$(dirname "$0")" ; pwd )"
cd $HOME

# Default values for jobs
def_walltime=4:00:00
def_shell=2d

function usage {
cat << EOF
Usage: vncmgr [COMMAND]

Create and manage remote desktops using VNC on Casper.
This script helps you start a batch job on Casper, within
which your VNC server will run. You can then connect to
the remote server using a VNC viewer on your local client
machine. Compatible viewers include TurboVNC and TigerVNC.

If no COMMAND is given, vncmgr will run in an interactive
mode, with instructions given in a menu. If a COMMAND is
provided, vncmgr will run in a batch mode.

Available COMMANDs:
    list        display all active VNC sessions
    create      start a new VNC server within a Casper job
    query       get information on using an existing session
    kill        terminate a running VNC server and batch job

For every mode except for list, you can specify an optional
session name. The session name must appear immediately after
the COMMAND. If no session name is given, the name "default"
is assumed.

Create Mode Options
    The following options are also available in create mode:

        -A, --account=PROJECT   project code for the job
                                (or use \$DAV_PROJECT env variable)
        -t, --time=WALLTIME     length of time that the Slurm job
                                will perist (man sbatch for format)
        -d, --desktop=SHELL     type of desktop shell VNC will use
                                (2d, gnome-session, or startkde)
        -j, --job-opts="OPTS"   additional arguments to pass to the
                                sbatch command (see man sbatch)
        -v, --vnc-opts="OPTS"   arguments to pass to the vncserver
                                command (see man vncserver)

Examples

1. Create a session with default name and two-hour wallclock:

    vncmgr create -A PROJ0001 -t 2:00:00

2. Query a session called workday:

    vncmgr query workday

3. Run in interactive mode from outside Cheyenne:

    ssh -t -L $USER cheyenne.ucar.edu $my_dir/vncmgr

EOF
}

function menu {
cat << EOF
--------------------------------------------------------
             Manage VNC desktops on Casper
--------------------------------------------------------

Active servers, reported as Slurm jobs:

$job_data

Use the following options to create a new VNC session,
query an existing session (which will provide you with a
new one-time password), or kill a running VNC session
and end the Slurm job associated with it.

Options:
    create [SESSION]
    query [SESSION]
    kill [SESSION]
    refresh
    exit

EOF
}

function check_server {
    SECONDS=0
    echo "Waiting for VNC server to initialize ..."
    
    while [[ ! -s .$job_name ]]; do
        if [[ $SECONDS -ge 60 ]]; then
            echo "Fatal error: server initialization timeout"
            exit 2
        fi
    done

    if [[ $(cat ~/.$job_name) =~ casper[0-9]+:[0-9]+$ ]]; then
        host_info=$(cat .$job_name)
        host_addr=${host_info%:*}.ucar.edu
        host_disp=${host_info#*:}
        host_port=$((host_disp + 5900))
    else
        echo "Fatal error: unexpected output from VNC server. Cancelling job."
        scancel $vnc_jobid
        echo -e "VNC output:\n"
        cat .$job_name
        exit 2
    fi
}

function create_job {
    job_shell=$(echo ${SHELL##*/} | sed 's/tcsh/csh/')
    job_project=${job_project:-$DAV_PROJECT}
    job_walltime=${job_walltime:-$def_walltime}
    desktop_setup="TVNC_WM=${vnc_desktop:-$def_shell}"
    export desktop_setup vnc_opts my_dir

    echo "Creating new VNC session ($vnc_session) ..."
    envsubst '$desktop_setup $vnc_opts $my_dir' < $my_dir/.${job_shell}script > .vncscript.slurm

    # Submit batch script to Slurm
    echo -e "\nSubmitting batch job to Slurm"
    vnc_jobid=$(sbatch $job_opts -A $job_project -t $job_walltime -J $job_name .vncscript.slurm | awk '{ print $NF }')

    if [[ $? != 0 ]]; then
        echo "Fatal error: could not submit Slurm job"
        exit 2
    fi

    rm -f .$job_name

    echo "Waiting for job to start ..."
    
    while [[ $job_status != R\ * ]]; do
        if [[ $SECONDS -gt 8 ]]; then
            job_status=$(squeue -j $vnc_jobid -O statecompact -h)
        fi
    done 

    check_server

    # Create tunnel file to be used for non VPN sessions
    export host_port host_disp vnc_jobid
    envsubst '$host_port $host_disp $vnc_jobid' < $my_dir/.vnctunnel > .vnctunnel-$vnc_session
}

function display_job {
time_left=$(squeue -j $vnc_jobid -O timeleft -h | sed 's/ *$//')
clear

if [[ $(pinky -f $USER | awk '{print $NF}') == 128.117* ]]; then
cat << EOF

You appear to be connected to the NCAR Internal Network either directly
or via the NCAR VPN. Therefore, an SSH tunnel is not necessary to stream
desktop data to your local computer.

Please load a VNC viewer on your local machine (e.g., TurboVNC or TigerVNC),
and connect to the following host:

    $host_addr:$host_port

The viewer will ask for a *one-time* password. Use the following:

    $(ssh $host_addr "/usr/local/bin/vncpasswd -display :$host_disp -o |& cut -d ' ' -f5")

Warning: if you disconnect from the NCAR Internal Network or VPN, your
         VNC connection will be disrupted.

EOF
else
cat << EOF

To activate the VNC session on your client machine (external network):

  1) Create an SSH tunnel to stream desktop data to your local computer:

       ssh -l $USER -L $host_port:localhost4:$host_port $host_addr "bash .vnctunnel-$vnc_session"
  
  2) Follow instructions given in local terminal. The local terminal session
     will hang after creating the tunnel. This behavior is normal.

If you disconnect from the VNC server and wish to reconnect,
you will need to restart the tunnel to generate a new password.
This VNC server will timeout and shut down automatically after ${time_left}.

To end the Slurm job and shut down the VNC server:

  1) Use scancel to end the VNC server job:

       scancel $vnc_jobid

Note: you can avoid the tunneling step if using the NCAR internal network
      or the NCAR VPN (https://www2.cisl.ucar.edu/user-support/vpn-access)
          
EOF
fi
}

function query_session {
    vnc_session=$(sed 's/vncs-//' <<< ${1:-default})
    job_name=vncs-$vnc_session
    vnc_jobid=$(squeue -u $USER -n $job_name -O jobid -h | sed 's/ *$//')
} 

function query_job {
    if [[ ${vnc_jobid}z != z ]]; then
        echo "Querying $vnc_session with job ID $vnc_jobid ..."
        check_server
        display_job
    else
        echo "Error: no session found with name $vnc_session"
    fi
}

function kill_job {
    if [[ ${vnc_jobid}z != z ]]; then
        echo "Cancelling VNC session ($vnc_session) with job ID $vnc_jobid ..."
        scancel $vnc_jobid
    else
        echo "Error: no session found with name $vnc_session"
    fi
}

function live_driver {
    job_data=$(squeue -u $USER -o "%.7i %.10u %.5t %.10P %.10L %j" -t pd,r | grep -e JOBID -e 'vncs-' --color=never)
    clear
    menu

    read -e -p 'Selection? ' -a user_opts
    echo
    history -s "${user_opts[@]}"

    query_session ${user_opts[1]}

    if [[ create == ${user_opts[0]}* ]]; then
        if [[ ${vnc_jobid}z != z ]]; then
            echo "Error: VNC session with name $vnc_session already exists"
        else
            clear
            echo -e "\nUse these options to configure your VNC desktop session and Slurm job."
            echo "The maximum time allowed for a job is 24:00:00. Available desktop shells"
            echo -e "include 2d (GNOME2), gnome-session (GNOME3), and startkde (KDE).\n"

            read -e -p "Enter project code for VNC job (default=$DAV_PROJECT): " job_project
            read -e -p "Enter time limit for VNC job (default=$def_walltime): " job_walltime
            read -e -p "Choose desktop shell for VNC job (default=$def_shell): " vnc_desktop
            read -e -p "Additional Slurm arguments for VNC job (optional): " -a job_opts
            read -e -p "Arguments to forward to vncserver program (optional): " -a vnc_opts

            create_job
            display_job
        fi
    elif [[ query == ${user_opts[0]}* ]]; then
        query_job
    elif [[ kill == ${user_opts[0]}* ]]; then
        kill_job
    else
        return
    fi
    
    read -n 1 -r -s -p 'Press enter to continue...'
}

# Run in batch if arguments, otherwise use live mode
if [[ $# -gt 0 ]]; then
    # Help flag intercept
    if [[ " $@ " == *" --help "* ]] || [[ " $@ " == *" -h "* ]]; then
        usage
        exit
    fi

    sub_com=$1; shift

    if [[ list == $sub_com* ]]; then
        echo -e "\nActive servers, reported as Slurm jobs:\n"
        squeue -u $USER -o "%.7i %.10u %.5t %.10P %.10L %j" -t pd,r | grep -e JOBID -e 'vncs-' --color=never
        echo
        exit
    fi

    if [[ $1 =~ ^[^-].* ]]; then
        user_sess=$1; shift
    fi

    query_session $user_sess

    if [[ create == $sub_com* ]]; then
        if [[ ${vnc_jobid}z != z ]]; then
            echo "VNC session ($vnc_session) is already running"
            query_job
            exit
        fi

        while [[ $# -gt 0 ]]; do
            case $1 in
                -A|--account*)
                    [[ $1 == *=* ]] && job_project=${1#*=} || job_project=$2
                    shift; ;;
                -t|--time*)
                    [[ $1 == *=* ]] && job_walltime=${1#*=} || job_walltime=$2
                    job_walltime=$2
                    shift; ;;
                -d|--desktop*)
                    [[ $1 == *=* ]] && vnc_desktop=${1#*=} || vnc_desktop=$2
                    shift; ;;
                -j|--job-opts*)
                    [[ $1 == *=* ]] && job_opts=${1#*=} || job_opts=$2
                    shift; ;;
                -v|--vnc-opts*)
                    [[ $1 == *=* ]] && vnc_opts=${1#*=} || vnc_opts=$2
                    shift; ;;
                *)
                    echo "Error: unrecognized argument to create ($1)"
                    ;;
            esac
            shift
        done

        create_job
        display_job
    elif [[ query == $sub_com* ]]; then
        query_job
    elif [[ kill == $sub_com* ]]; then
        kill_job
    else
        echo "Fatal error: subcommand $sub_com not recognized"
        exit 1
    fi
else
    while true; do
        live_driver

        if [[ ${user_opts[0]}z != z ]] && [[ exit == ${user_opts[0]}* ]]; then
            break
        fi
    done
fi
