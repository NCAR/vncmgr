#!/bin/bash
#
#   This script helps users create and manage their
#   VNC sessions on the Casper cluster.
#
#   Author:         Brian Vanderwende
#   Last Revised:   11:35, 24 May 2021
#

# Make sure environment is configured to run VNC jobs
. /etc/profile >& /dev/null
my_dir="$( cd "$(dirname "$0")" ; pwd )"
cd $HOME; mkdir -p .vncmgr
module load ncarenv

# Set up cross-server submission
if [[ $NCAR_HOST == cheyenne ]]; then
    ds=casper
else
    ds=
fi

# Default values for jobs
def_walltime=4:00:00
def_shell=2d

# qstat display settings
qstat_bin=/glade/u/apps/opt/qstat-cache/qstat
qstat_fmt="%-9.9s %-16s %2s %4s %7s %14s\n"
qstat_labels="JobID Name S NCPU ReqMem Time(HH:MM)"
qstat_splits="----- ---- - ---- ------ -------------"

function usage {
cat << EOF
Usage: vncmgr [COMMAND]

Create and manage remote desktops using VNC on Casper.
This script helps you start a batch job on Casper, within
which your VNC server will run. You can then connect to
the remote server using a VNC viewer on your local client
machine. Compatible viewers include TurboVNC and TigerVNC.

If no COMMAND is given, vncmgr will run in an interactive
mode, with instructions given in a menu. If a COMMAND is
provided, vncmgr will run in a command-line mode.

Available COMMANDs:
    list        display all active VNC sessions
    create      start a new VNC server within a Casper job
    query       get information on using an existing session
    kill        terminate a running VNC server and batch job

For every mode except for list, you can specify an optional
session name. The session name must appear immediately after
the COMMAND. If no session name is given, the name "default"
is assumed.

Create Command Options
    The following options are also available when using create:

        -A, --account=PROJECT   project code for the job
                                (or use \$DAV_PROJECT env variable)
        -t, --time=WALLTIME     length of time that the PBS job
                                will perist (man qsub for format)
        -d, --desktop=SHELL     type of desktop shell VNC will use
                                (2d, gnome-session, or startkde)
        -j, --job-opts="OPTS"   additional arguments to pass to the
                                qsub command (see man qsub)
        -v, --vnc-opts="OPTS"   arguments to pass to the vncserver
                                command (see man vncserver)

Examples

1. Create a session with default name and two-hour wallclock:

    vncmgr create -A PROJ0001 -t 2:00:00

2. Query a session called workday:

    vncmgr query workday

3. Run in interactive mode from outside Cheyenne:

    ssh -t -L $USER cheyenne.ucar.edu $my_dir/vncmgr

EOF
}

function menu {
cat << EOF
--------------------------------------------------------
             Manage VNC desktops on Casper
--------------------------------------------------------

Active servers, reported as PBS jobs:

$(printf "$qstat_fmt" $qstat_labels)
$(printf "$qstat_fmt" $qstat_splits)
$job_data

Use the following options to create a new VNC session,
query an existing session (which will provide you with a
new one-time password), or kill a running VNC session
and end the PBS job associated with it.

Options:
    create [SESSION]
    query [SESSION]
    kill [SESSION]
    refresh
    exit

EOF
}

function check_server {
    SECONDS=0
    echo "Waiting for VNC server to initialize ..."
    
    while [[ ! -s .vncmgr/$job_name ]]; do
        if [[ $SECONDS -ge 60 ]]; then
            >&2 echo "Error: server initialization timeout"
            exit 1
        fi

        sleep 1
    done

    sleep 2

    host_info=$(grep --color=never vncmgr-display .vncmgr/$job_name | awk '{print $2}')

    if [[ -n $host_info ]]; then
        host_addr=${host_info%:*}.ucar.edu
        host_disp=${host_info#*:}
        host_port=$((host_disp + 5900))
    else
        >&2 echo "Error: unexpected output from VNC server. Cancelling job."
        qdel$ds $vnc_jobid >& /dev/null
        check_job_status ""
        >&2 echo -e "VNC output:\n"
        >&2 cat .vncmgr/$job_name
        exit 1
    fi
}

function check_job_status {
    SECONDS=0
    
    while true; do
        if [[ $SECONDS -gt 5 ]]; then
            job_status=$($qstat_bin @casper $vnc_jobid | grep ^$vnc_jobid | awk '{print $5}')

            if [[ $job_status == $1 ]]; then
                break
            fi
        fi

        sleep 1
    done
}

function create_job {
    # Make sure job_opts includes necessary settings
    if [[ $job_opts == *":ngpus="* ]]; then
        if [[ ! $job_opts =~ .*:ngpus=1[:\ ].* ]]; then
            opt_msg=True
            echo "Resource chunks must have ngpus=1; altering custom PBS options ..."
            job_opts=$(sed 's|:ngpus=[1-9]*|:ngpus=1|' <<< $job_opts)
        fi
    elif [[ $job_opts == *"select="* ]]; then
        opt_msg=True
        echo "Resource chunks must have ngpus=1; altering custom PBS options ..."
        job_opts=$(sed 's|\(select=[^ ]*\)|\1:ngpus=1|' <<< $job_opts)
    fi

    if [[ $job_opts == *"gpu_type="* ]]; then
        if [[ $job_opts != *"gpu_type=gp100"* ]]; then
            opt_msg=True
            echo "gpu_type must be set to gp100; altering custom PBS options ..."
            job_opts=$(sed 's|gpu_type=[^ ]*|gpu_type=gp100|' <<< $job_opts)
        fi
    fi

    if [[ $opt_msg == True ]]; then
        echo "New job-opts = $job_opts"
    fi

    job_shell=$(echo ${SHELL##*/} | sed 's/tcsh/csh/')
    job_project=${job_project:-$DAV_PROJECT}
    job_walltime=${job_walltime:-$def_walltime}
    job_args="$job_opts -A $job_project -l walltime=$job_walltime -N $job_name -o .vncmgr/$job_name"
    desktop_setup="TVNC_WM=${vnc_desktop:-$def_shell}"
    export desktop_setup vnc_opts my_dir

    if [[ -z $job_project ]]; then
        >&2 echo -e "\nError: no valid project account given for PBS job"
        >&2 echo "       specify $perm_msg or with DAV_PROJECT variable"
        exit 1
    fi

    echo "Creating new VNC session ($vnc_session) ..."
    envsubst '$desktop_setup $vnc_opts $my_dir' < $my_dir/.${job_shell}script > .vncmgr/script.pbs
    echo -e "\n# User opts: vncmgr $user_args" >> .vncmgr/script.pbs
    echo "# qsub opts: qsub$ds $job_args .vncmgr/script.pbs" >> .vncmgr/script.pbs

    # Submit batch script to PBS
    echo -e "\nSubmitting batch job to PBS"
    rm -f .vncmgr/$job_name
    vnc_jobid=$(qsub$ds $job_args .vncmgr/script.pbs | sed -n 's/\([0-9]*\).casper.*/\1/p'; exit ${PIPESTATUS[0]})

    if [[ $? != 0 ]]; then
        exit 1
    fi

    echo "Waiting for job to start ..."

    check_job_status R
    check_server

    # Create tunnel file to be used for non VPN sessions
    export host_port host_disp vnc_jobid
    envsubst '$host_port $host_disp $vnc_jobid' < $my_dir/.vnctunnel > .vncmgr/tunnel-$vnc_session
    chmod u+x .vncmgr/tunnel-$vnc_session
}

function display_job {
time_left=$($qstat_bin @casper -w $vnc_jobid | grep "^$vnc_jobid" | awk '{print $11" / "$9}')
clear
cat << EOF
Use *one* of the following methods to connect to your VNC session. Instructions
are given for both direct remote access via tunneling and access via the UCAR VPN.
(VPN instructions: https://www2.cisl.ucar.edu/user-support/vpn-access)

  SSH TUNNEL METHOD

  Create an SSH tunnel to stream desktop data to your local computer:

    ssh -l $USER -L $host_port:localhost4:$host_port $host_addr "bash ~/.vncmgr/tunnel-$vnc_session"
  
  Follow instructions given in local terminal. The local terminal session will
  hang after creating the tunnel. This behavior is normal.

  INTERNAL NETWORK METHOD

  If you are connected to the Internal Network (on-site or via UCAR VPN), you
  can simply load TurboVNC or TigerVNC and connect to the follow host:

    $host_addr:$host_port

  The viewer will ask for a *one-time* password. Use $(ssh $host_addr "/usr/local/bin/vncpasswd -display :$host_disp -o |& cut -d ' ' -f5" 2> /dev/null | grep "^[0-9]").

  Warning: if you disconnect from the VPN, your VNC connection will be disrupted.

If you disconnect from the VNC server and wish to reconnect, you will need to
generate a new password. This VNC server will timeout and shut down automatically
once wallclock limit is reached (${time_left}).

To end the PBS job and shut down the VNC server, run:

  vncmgr kill $vnc_session

EOF
}

function query_session {
    vnc_session=$(sed 's/vncs-//' <<< ${1:-default})
    
    if [[ ${#vnc_session} -gt 10 ]]; then
        >&2 echo "Error: max session name length is 10 chars"
        exit 1
    fi

    job_name=vncs-$vnc_session
    vnc_jobid=$($qstat_bin @casper -u $USER -w | awk -v name=$job_name '$4 == name && $10 != "E" { split($1, id, "."); print id[1] }')
} 

function query_job {
    if [[ ${vnc_jobid}z != z ]]; then
        echo "Querying $vnc_session with job ID $vnc_jobid ..."
        check_server
        display_job
    else
        >&2 echo "No session found with name $vnc_session"
    fi
}

function kill_job {
    if [[ ${vnc_jobid}z != z ]]; then
        echo "Cancelling VNC session ($vnc_session) with job ID $vnc_jobid ..."
        qdel$ds $vnc_jobid >& /dev/null
        echo "Waiting for job records to refresh ..."
        check_job_status ""
    else
        >&2 echo "No session found with name $vnc_session"
    fi
}

function map_desktop {
    case $vnc_desktop in
        gnome2|GNOME2)
            vnc_desktop=2d
            ;;
        gnome3|GNOME3)
            vnc_desktop=gnome-session
            ;;
        kde|KDE)
            vnc_desktop=startkde
            ;;
    esac
}

function live_driver {
    job_data=$($qstat_bin @casper -u $USER -w | awk -v qf="$qstat_fmt" '$4 ~ /vncs-/ && $10 != "E" {split($1, id, "."); printf qf, id[1], $4, $10, $7, $8, $11" / "$9}')
    clear
    menu

    read -e -p 'Selection? ' -a user_opts
    echo
    history -s "${user_opts[@]}"

    query_session ${user_opts[1]}

    if [[ create == ${user_opts[0]}* ]]; then
        perm_msg="interactively"
        if [[ ${vnc_jobid}z != z ]]; then
            echo "Error: VNC session with name $vnc_session already exists"
        else
            clear
            echo -e "\nUse these options to configure your VNC desktop session and PBS job."
            echo "The maximum time allowed for a job is 24:00:00. Available desktop shells"
            echo -e "include 2d (GNOME2), gnome-session (GNOME3), and startkde (KDE).\n"

            read -e -p "Enter project code for VNC job (default=$DAV_PROJECT): " job_project
            read -e -p "Enter time limit for VNC job (default=$def_walltime): " job_walltime
            read -e -p "Choose desktop shell for VNC job (default=$def_shell): " vnc_desktop
            read -e -p "Additional PBS arguments for VNC job (optional): " job_opts
            read -e -p "Arguments to forward to vncserver program (optional): " vnc_opts
            echo

            map_desktop
            create_job
            display_job
        fi
    elif [[ query == ${user_opts[0]}* ]]; then
        query_job
    elif [[ kill == ${user_opts[0]}* ]]; then
        kill_job
    else
        return
    fi
    
    read -n 1 -r -s -p 'Press enter to continue...'
}

# Run in batch if arguments, otherwise use live mode
if [[ $# -gt 0 ]]; then
    user_args="$@"
    perm_msg="using -A flag"

    # Help flag intercept
    if [[ " $@ " == *" --help "* ]] || [[ " $@ " == *" -h "* ]]; then
        usage
        exit
    fi

    sub_com=$1; shift

    if [[ list == $sub_com* ]]; then
        echo -e "\nActive servers, reported as PBS jobs:\n"
        printf "$qstat_fmt" $qstat_labels
        printf "$qstat_fmt" $qstat_splits
        $qstat_bin @casper -u $USER -w | awk -v qf="$qstat_fmt" '$4 ~ /vncs-/ && $10 != "E" {split($1, id, "."); printf qf, id[1], $4, $10, $7, $8, $11" / "$9}'
        echo
        exit
    fi

    if [[ $1 =~ ^[^-].* ]]; then
        user_sess=$1; shift
    fi

    query_session $user_sess

    if [[ create == $sub_com* ]]; then
        if [[ ${vnc_jobid}z != z ]]; then
            echo "VNC session ($vnc_session) is already running"
            query_job
            exit
        fi

        while [[ $# -gt 0 ]]; do
            if [[ ! -z $read_value ]]; then
                declare "$read_value=$1"
                unset read_value
            else
                case $1 in
                    -A|--account*)
                        [[ $1 == *=* ]] && job_project=${1#*=} || read_value=job_project
                        ;;
                    -t|--time*)
                        [[ $1 == *=* ]] && job_walltime=${1#*=} || read_value=job_walltime
                        ;;
                    -d|--desktop*)
                        [[ $1 == *=* ]] && vnc_desktop=${1#*=} || read_value=vnc_desktop
                        map_desktop
                        ;;
                    -j|--job-opts*)
                        [[ $1 == *=* ]] && job_opts=${1#*=} || read_value=job_opts
                        ;;
                    -v|--vnc-opts*)
                        [[ $1 == *=* ]] && vnc_opts=${1#*=} || read_value=vnc_opts
                        ;;
                    *)
                        >&2 echo "Error: unrecognized argument to create ($1)"
                        
                        if [[ $1 != -* ]]; then
                            >&2 echo "       (session name must be given immediately after create)"
                        fi

                        exit 1
                        ;;
                esac
            fi

            shift
        done

        create_job
        display_job
    elif [[ query == $sub_com* ]]; then
        query_job
    elif [[ kill == $sub_com* ]]; then
        kill_job
    else
        >&2 echo "Error: subcommand $sub_com not recognized"
        exit 1
    fi
else
    while true; do
        live_driver

        if [[ ${user_opts[0]}z != z ]] && [[ exit == ${user_opts[0]}* ]]; then
            break
        fi
    done
fi
